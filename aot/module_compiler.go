package aot

type moduleCompiler struct {
	printer
	moduleInfo
}

func (c *moduleCompiler) compile() {
	c.genModule()
	c.genNew()
	c.genUtils()
	c.println("")
	m := c.module
	importedFuncCount := len(c.importedFuncs)
	for i, ftIdx := range m.FuncSec {
		fc := newFuncCompiler(c.module)
		fIdx := importedFuncCount + i
		ft := m.TypeSec[ftIdx]
		code := m.CodeSec[i]
		c.println(fc.compile(fIdx, ft, code))
	}
}

func (c *moduleCompiler) genModule() {
	c.print(`// Code generated by wasm.go. DO NOT EDIT.

package main

import (
	"math"

	"github.com/zxh0/wasm.go/binary"
	"github.com/zxh0/wasm.go/instance"
	"github.com/zxh0/wasm.go/interpreter"
)

type aotModule struct {
	importedFuncs []instance.Function
	table         instance.Table
	memory        instance.Memory
	globals       []instance.Global
}
`)
}

func (c *moduleCompiler) genNew() {
	funcCount := len(c.importedFuncs) + len(c.module.FuncSec)
	globalCount := len(c.importedGlobals) + len(c.module.GlobalSec)
	c.printf(`
func Instantiate(iMap instance.Map) instance.Instance {
	m := &aotModule{
		importedFuncs: make([]instance.Function, %d),
		globals:       make([]uint64, %d),
	}
`, funcCount, globalCount)

	for i, imp := range c.importedFuncs {
		c.printf("	m.importedFuncs[%d] = iMap[%s].Get(%s).(instance.Function)\n",
			i, imp.Module, imp.Name)
	}
	if len(c.importedTables) > 0 {
		c.printf("	m.table = iMap[%s].Get(%s).(instance.Table)\n",
			c.importedTables[0].Module, c.importedTables[0].Name)
	} else {
		c.printf("	m.table = interpreter.NewTable()\n") // TODO
	}
	if len(c.importedMemories) > 0 {
		c.printf("	m.memory = iMap[%s].Get(%s).(instance.Memory)\n",
			c.importedTables[0].Module, c.importedTables[0].Name)
	} else {
		c.printf("	m.memory = interpreter.NewMemory()\n") // TODO
	}
	for i, imp := range c.importedGlobals {
		c.printf("	m.globals[%d] = iMap[%s].Get(%s).(instance.Global)\n",
			i, imp.Module, imp.Name)
	}
	for i, _ := range c.module.GlobalSec {
		c.printf("	m.globals[%d] = interpreter.NewGlobal()", // TODO
			len(c.importedGlobals)+i)
	}

	c.println("	return m\n}")
}

func (c *moduleCompiler) genUtils() {
	c.print(`
// utils
func b2i(b bool) uint64 {
	if b { return 1 } else { return 0 }
}
func f32(i uint64) float32 {
	return math.Float32frombits(uint32(i))
}
func u32(f float32) uint64 {
	return uint64(math.Float32bits(f))
}
func f64(i uint64) float64 {
	return math.Float64frombits(i)
}
func u64(f float64) uint64 {
	return math.Float64bits(f)
}
`)
}
